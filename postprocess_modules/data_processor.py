"""
Filename: data_processor.py

Authors:
	Jason Youn - jyoun@ucdavis.edu

Description:
	Process the integrated data by 1) removing temporal data
	and 2) creating a 'Label' column to denote positive / negative.

To-do:
	1. Use .xml to process.
"""

import numpy as np
import pandas as pd
import logging as log

class DataProcessor():
	"""
	Class for processing the integrated data generated by 'integrate_data.py'.
	"""

	# predicates
	CRTA_STR = 'confers resistance to antibiotic'
	CNRTA_STR = 'confers no resistance to antibiotic'
	UBA_STR = 'upregulated by antibiotic'
	NUBA_STR = 'not upregulated by antibiotic'
	R_STR = 'represses'
	NR_STR = 'no represses'
	A_STR = 'activates'
	NA_STR = 'no activates'
	HAS_STR = 'has'
	III_STR = 'is involved in'
	IPO_STR = 'is part of'
	TB_STR = 'targeted by'

	# drop these columns because it's not necessary for network training
	COLUMN_NAMES_TO_DROP = ['Belief', 'Source size', 'Sources']

	def __init__(self, data_path):
		"""
		Class constructor for DataProcessor.

		Inputs:
			data_path: full file path pointing to the integrated file
		"""
		self.data_path = data_path

	def reformat_data(self):
		"""
		Remove temporal data and append column 'Label'
		to denote positive / negative sample.

		Returns:
			pd_data: reformated data where
				pd_data.columns.values = ['Subject' 'Predicate' 'Object' 'Label']
		"""
		# drop unnecessary columns
		pd_data = pd.read_csv(self.data_path, sep = '\t').drop(self.COLUMN_NAMES_TO_DROP, axis=1)

		# remove temporal information
		pd_data = self._remove_temporal_info(pd_data)

		# now drop duplicates resulting from absence of temporal info
		log.info('Dropping duplicates...')
		pd_data.drop_duplicates(inplace=True)

		predicate_group = pd_data.groupby('Predicate')
		log.debug('Size of data grouped by predicates: \n{}'.format(predicate_group.size()))

		# fill label column
		pd_data = self._fill_label_column(pd_data)

		label_group = pd_data.groupby('Label')
		log.debug('Size of data grouped by label: \n{}'.format(label_group.size()))

		# drop duplicates that results from removing the temporal info and using the Label column
		log.info('Dropping duplicates...')
		pd_data = pd_data.drop_duplicates(subset=['Subject', 'Predicate', 'Object'], keep=False)

		return pd_data

	def _remove_temporal_info(self, pd_data):
		"""
		(Private) Remove temporal information.
		For now, there exists temporal info only for C(N)RTA and (N)UBA predicates.

		Inputs:
			pd_data: data which contains temporal information

		Returns:
			pd_data: data with temporal information removed
		"""
		log.info('Removing temporal info from the predicates...')

		# remove temporal data in predicate
		pd_data.loc[pd_data['Predicate'].str.startswith(self.CRTA_STR), 'Predicate'] = self.CRTA_STR
		pd_data.loc[pd_data['Predicate'].str.startswith(self.CNRTA_STR), 'Predicate'] = self.CNRTA_STR

		pd_data.loc[pd_data['Predicate'].str.startswith(self.UBA_STR), 'Predicate'] = self.UBA_STR
		pd_data.loc[pd_data['Predicate'].str.startswith(self.NUBA_STR), 'Predicate'] = self.NUBA_STR

		return pd_data

	def _fill_label_column(self, pd_data):
		"""
		(Private) Instead of using negative statement in the predicates,
		convert the negative predicate to positive predicate and give negative label.

		Inputs:
			pd_data: data to process

		Returns:
			pd_data: processed data with column 'Label' added
		"""
		positive = '1'
		negative = '-1'

		log.info('Filling label column with positives and negatives...')

		# append 'Label' column because it doesn't exist yet
		pd_data['Label'] = np.nan

		# confers (no) resistance to antibiotic
		index = pd_data['Predicate'].str.match(self.CRTA_STR)
		pd_data.loc[index, 'Label'] = positive

		index = pd_data['Predicate'].str.match(self.CNRTA_STR)
		pd_data.loc[index, 'Label'] = negative
		pd_data.loc[index, 'Predicate'] = self.CRTA_STR

		# (not) upregulated by antibiotic
		index = pd_data['Predicate'].str.match(self.UBA_STR)
		pd_data.loc[index, 'Label'] = positive

		index = pd_data['Predicate'].str.match(self.NUBA_STR)
		pd_data.loc[index, 'Label'] = negative
		pd_data.loc[index, 'Predicate'] = self.UBA_STR

		# (no) activates
		index = pd_data['Predicate'].str.match(self.A_STR)
		pd_data.loc[index, 'Label'] = positive

		index = pd_data['Predicate'].str.match(self.NA_STR)
		pd_data.loc[index, 'Label'] = negative
		pd_data.loc[index, 'Predicate'] = self.A_STR

		# (no) represses
		index = pd_data['Predicate'].str.match(self.R_STR)
		pd_data.loc[index, 'Label'] = positive

		index = pd_data['Predicate'].str.match(self.NR_STR)
		pd_data.loc[index, 'Label'] = negative
		pd_data.loc[index, 'Predicate'] = self.R_STR

		# fill rest of the 4 predicate labels with just
		# positives because they do not have negatives
		pd_data.loc[pd_data['Predicate'].str.match(self.HAS_STR), 'Label'] = positive
		pd_data.loc[pd_data['Predicate'].str.match(self.III_STR), 'Label'] = positive
		pd_data.loc[pd_data['Predicate'].str.match(self.IPO_STR), 'Label'] = positive
		pd_data.loc[pd_data['Predicate'].str.match(self.TB_STR), 'Label'] = positive

		# make sure there is no missing value in the label column
		assert pd_data['Label'].isna().sum() == 0

		return pd_data
